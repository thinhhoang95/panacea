function [Xout] = panacea_odet(Add, Bdd, imuTs, detectionTs, out, window_length, f)
    % close all;
    fprintf('Starting Panacea Algorithm for Object Detection... \n');
    fprintf('State Estimation for Autonomous Helicopter Landing by Hoang Dinh Thinh (1970062) \n');
    fprintf('Author: Hoang Dinh Thinh \n');
    fprintf('Starting memory alloc... ');
    % global Aa Ba imuTs trackingTs out N_window Q R;
    % Allocation of variables
    X = zeros(6,length(out.accel.time));
    P = zeros(6,6,length(out.accel.time));
    Xw = zeros(6,window_length);
    Xww = zeros(6,window_length);
    Pw = zeros(6,6,window_length);
    Pww = zeros(6,6,window_length);
    uw = zeros(3,window_length);
    fprintf('OK! \n');
    fprintf('Initializing window variables... ');
    % R: covariance of the acceleration, Q: measurement of detection
    R = 0.5*eye(3);
    Q = diag([1e-5 1e-5 8]);
    imu_cursor = 1; % cursor of the current state in the Xw
    detection_cursor = 1;
    next_detection_clock = out.xiod.time(detection_cursor + 1);
    will_adjust_cursor = false;
    Qi = inv(Q);
    fprintf('OK! \n Panacea ODE is started... ');
    for time=1:length(out.accel.time)
        % For each IMU data received, perform reckoning of the new position
        % and velocity:
        clock = time * imuTs;
        a = out.accel.signals.values(time,:);
        imu_cursor = imu_cursor + 1;
        Xww(:,imu_cursor) = Add * Xww(:,imu_cursor - 1) + Bdd * a';
        Pww(:,:,imu_cursor) = Add * Pww(:,:,imu_cursor - 1) * Add' + Bdd * R * Bdd';
        uw(:,imu_cursor - 1) = a';
        if (clock>next_detection_clock)
            % Once AI detection result is available, perform the correction
            % step 
            % detection_cursor indicates the IMU state which object
            % detection starts, and detection_cursor+1 is where it ends
            % We refine the first state of the window 
            xes = out.xiod.Data(:,:,detection_cursor);
            xe = xes(1);
            ye = xes(2);
            F1 = [f, 0, -xe; 0, f, -ye; 0, 0, -1];
            F2 = [eye(3), zeros(3)];
            H = F1*F2;
            state = Xww(:,1); % the first state is refined
            P = Pww(:,:,1);
            z = [0; 0; -out.xtod.Data(detection_cursor,3)];
            if (det(P)<1e-12)
                disp(det(P));
                % The matrix is near singular, skip the correction step
                Xww(:,1) = state;
                Pww(:,:,1) = P;
            else
                S = H*P*H'+Q;
                Kg = P*H'*inv(S);
                state_hat = state + Kg * (z - H*state);
                covar_hat = (eye(size(state,1)) - Kg*H)*P;
                % Pi = inv(P);
                % state_hat = inv(H'*Qi*H + Pi) * (H'*Qi*z + Pi*state); % maximum-a-posteriori estimation
                % Make state_hat the first state of the window
                Xww(:,1) = state_hat;
                fprintf('State at %d second is: \n', 
                % covar_hat = inv(H'*Qi*H + Pi);
                Pww(:,:,1) = covar_hat;
                % Propagate the new estimation using acceleration upto the
                % present
                for q=1:imu_cursor - 1
                    Xww(:,q+1) = Add * Xww(:,q) + Bdd * uw(:,q);
                    Pww(:,:,q+1) = Add * Pww(:,:,q) * Add' + Bdd * R * Bdd';
                end
            end
            will_adjust_cursor = true;
            detection_cursor = detection_cursor + 1;
            if (detection_cursor >= length(out.xiod.time))
                detection_cursor = detection_cursor - 1;
            else
                next_detection_clock = out.xiod.time(detection_cursor + 1);
            end
        end
        X(:,time) = Xww(:,imu_cursor);
        P(:,:,time) = Pww(:,:,imu_cursor);
        if (will_adjust_cursor == true)
            Xww(:,1) = Xww(:,imu_cursor);
            Pww(:,:,1) = Pww(:,:,imu_cursor);
            imu_cursor = 1;
            will_adjust_cursor = false;
        end
    end
    Xout = X;
    fprintf('Done! \n Plotting data... ');
    figure
    plot(out.accel.time, Xout(1:3,:)');
    fprintf('Done! \n');
end